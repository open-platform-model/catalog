version: '3'

# Catalog CUE Modules Taskfile
# Self-contained tasks for catalog/v0/* modules (multi-module aware)
#
# This Taskfile can be run standalone from the catalog/ directory:
#   cd catalog && task fmt
#   cd catalog && task fmt MODULE=schemas
#   cd catalog && task version
#   cd catalog && task publish:local MODULE=schemas
#   cd catalog && task publish:all:local
#
# Or via root orchestration:
#   task module:fmt MODULE=schemas

# Silent by default - set TASK_VERBOSE=1 or use --verbose to show commands
silent: true

env:
  CUE_REGISTRY: '{{.LOCAL_REGISTRY}}+insecure'
  CUE_CACHE_DIR: '{{.TASKFILE_DIR}}/../.cue-cache'

vars:
  V0_DIR: v0
  LOCAL_REGISTRY: localhost:5000
  VERSION_FILE: versions.yml
  
  # Catalog modules in dependency order
  CATALOG_MODULES:
    - name: core
      path: core
      enabled: true
      deps: ""

    - name: schemas
      path: schemas
      enabled: true
      deps: ""

    - name: resources
      path: resources
      enabled: true
      deps: "core schemas"

    - name: policies
      path: policies
      enabled: true
      deps: "core schemas"

    - name: traits
      path: traits
      enabled: true
      deps: "core schemas resources"

    - name: blueprints
      path: blueprints
      enabled: true
      deps: "core schemas resources traits"

    - name: providers
      path: providers
      enabled: true
      deps: "core schemas resources traits"

    - name: examples
      path: examples
      enabled: true
      deps: "core schemas resources traits"

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  # ============================================================================
  # Formatting
  # ============================================================================

  fmt:
    desc: Format CUE files (all modules or specific MODULE)
    summary: |
      Format CUE files in catalog modules.

      Usage:
        task fmt              # Format all modules
        task fmt MODULE=schemas  # Format specific module
    vars:
      MODULE: '{{.MODULE | default ""}}'
    cmds:
      - |
        if [ -n "{{.MODULE}}" ]; then
          echo "Formatting {{.MODULE}}..."
          cd "{{.V0_DIR}}/{{.MODULE}}" && cue fmt ./...
          echo "Done"
        else
          echo "Formatting all catalog modules..."
          {{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}
          echo "  Formatting {{$mod.name}}..."
          (cd "{{$.V0_DIR}}/{{$mod.path}}" && cue fmt ./...) || true
          {{end}}{{end}}
          echo "Done"
        fi

  # ============================================================================
  # Validation
  # ============================================================================

  vet:
    desc: Validate CUE files (all modules or specific MODULE)
    summary: |
      Validate CUE files in catalog modules.

      Usage:
        task vet                        # Validate all modules
        task vet MODULE=schemas         # Validate specific module
        task vet CONCRETE=true          # Validate with concreteness checks
    vars:
      MODULE: '{{.MODULE | default ""}}'
      CONCRETE: '{{.CONCRETE | default "false"}}'
      VET_FLAGS: '{{if eq .CONCRETE "true"}}-c{{end}}'
    cmds:
      - |
        if [ -n "{{.MODULE}}" ]; then
          echo "Validating {{.MODULE}}{{if eq .CONCRETE "true"}} (concrete){{end}}..."
          cd "{{.V0_DIR}}/{{.MODULE}}" && cue vet {{.VET_FLAGS}} ./...
          echo "Done"
        else
          echo "Validating all catalog modules{{if eq .CONCRETE "true"}} (concrete){{end}}..."
          FAILED=""
          {{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}
          echo "  Validating {{$mod.name}}..."
          if ! (cd "{{$.V0_DIR}}/{{$mod.path}}" && cue vet {{$.VET_FLAGS}} ./... 2>&1); then
            FAILED="${FAILED} {{$mod.name}}"
          fi
          {{end}}{{end}}
          
          if [ -n "$FAILED" ]; then
            echo ""
            echo "Failed:${FAILED}"
            exit 1
          fi
          echo "Done"
        fi


  eval:
    desc: Evaluate CUE files (all modules or specific MODULE)
    summary: |
      Evaluate CUE files in catalog modules and check for errors.

      Usage:
        task eval                          # Evaluate all modules
        task eval MODULE=schemas           # Evaluate specific module
        task eval OUTPUT=out.cue           # Evaluate all, write to file
    vars:
      MODULE: '{{.MODULE | default ""}}'
      OUTPUT: '{{.OUTPUT | default ""}}'
      EVAL_REDIRECT: '{{if .OUTPUT}}> {{.OUTPUT}}{{end}}'
    cmds:
      - |
        if [ -n "{{.MODULE}}" ]; then
          echo "Evaluating {{.MODULE}}..."
          cd "{{.V0_DIR}}/{{.MODULE}}" && cue eval ./... {{.EVAL_REDIRECT}}
          echo "Done"
        else
          echo "Evaluating all catalog modules..."
          FAILED=""
          {{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}
          echo "  Evaluating {{$mod.name}}..."
          if ! (cd "{{$.V0_DIR}}/{{$mod.path}}" && cue eval ./... {{$.EVAL_REDIRECT}} 2>&1); then
            FAILED="${FAILED} {{$mod.name}}"
          fi
          {{end}}{{end}}
          
          if [ -n "$FAILED" ]; then
            echo ""
            echo "Failed:${FAILED}"
            exit 1
          fi
          echo "Done"
        fi
  # ============================================================================
  # Module Management
  # ============================================================================

  tidy:
    desc: Tidy module dependencies (all modules or specific MODULE)
    vars:
      MODULE: '{{.MODULE | default ""}}'
    cmds:
      - |
        if [ -n "{{.MODULE}}" ]; then
          echo "Tidying {{.MODULE}} dependencies..."
          cd "{{.V0_DIR}}/{{.MODULE}}" && cue mod tidy
          echo "Done"
        else
          echo "Tidying all catalog module dependencies..."
          {{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}
          echo "  Tidying {{$mod.name}}..."
          (cd "{{$.V0_DIR}}/{{$mod.path}}" && cue mod tidy) || true
          {{end}}{{end}}
          echo "Done"
        fi

  # ============================================================================
  # Watch Mode
  # ============================================================================

  watch:fmt:
    desc: Watch and auto-format on changes
    preconditions:
      - sh: command -v watchexec
        msg: "watchexec is required. Install: brew install watchexec"
    cmds:
      - |
        echo "Watching catalog modules for changes..."
        echo "Press Ctrl+C to stop"
        cd "{{.V0_DIR}}" && watchexec -e cue -- bash -c '
          {{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}
          (cd "{{$mod.path}}" && cue fmt ./...) || true
          {{end}}{{end}}
          echo "Formatted"
        '

  watch:vet:
    desc: Watch and auto-validate on changes
    preconditions:
      - sh: command -v watchexec
        msg: "watchexec is required. Install: brew install watchexec"
    cmds:
      - |
        echo "Watching catalog modules for changes..."
        echo "Press Ctrl+C to stop"
        cd "{{.V0_DIR}}" && watchexec -e cue -- bash -c '
          FAILED=""
          {{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}
          if ! (cd "{{$mod.path}}" && cue vet ./... 2>&1); then
            FAILED="${FAILED} {{$mod.name}}"
          fi
          {{end}}{{end}}
          if [ -n "$FAILED" ]; then
            echo "Failed:${FAILED}"
          else
            echo "All valid"
          fi
        '

  # ============================================================================
  # Combined Operations
  # ============================================================================

  check:
    desc: Run fmt and vet on all modules
    cmds:
      - task fmt
      - task vet

  # ============================================================================
  # Module Info
  # ============================================================================

  list:
    desc: List all catalog modules
    cmds:
      - |
        echo "Catalog Modules:"
        {{range $mod := .CATALOG_MODULES}}
        {{if $mod.enabled}}
        echo "  {{$mod.name}} ({{$mod.path}})"
        {{else}}
        echo "  {{$mod.name}} ({{$mod.path}}) (disabled)"
        {{end}}
        {{end}}

  # ============================================================================
  # Version Management
  # ============================================================================

  version:
    desc: Show module versions (all or specific MODULE)
    summary: |
      Display versions for catalog modules.

      Usage:
        task version              # Show all module versions
        task version MODULE=schemas  # Show specific module version
    vars:
      MODULE: '{{.MODULE | default ""}}'
    preconditions:
      - sh: command -v yq >/dev/null 2>&1
        msg: "yq is required. Install: brew install yq"
    cmds:
      - |
        if [ -n "{{.MODULE}}" ]; then
          VERSION=$(yq '.{{.MODULE}}.version' {{.VERSION_FILE}})
          echo "{{.MODULE}}: $VERSION"
        else
          echo "Catalog Module Versions"
          echo "======================="
          yq '.[] | key + ": " + .version' {{.VERSION_FILE}}
        fi

  version:bump:
    desc: Bump module version (MODULE required, TYPE=patch/minor/major)
    summary: |
      Bump the version for a specific catalog module following SemVer.

      Usage:
        task version:bump MODULE=schemas              # Bump patch (default)
        task version:bump MODULE=schemas TYPE=patch   # v0.1.0 -> v0.1.1
        task version:bump MODULE=schemas TYPE=minor   # v0.1.0 -> v0.2.0
        task version:bump MODULE=schemas TYPE=major   # v0.1.0 -> v1.0.0
    vars:
      MODULE: '{{.MODULE | default ""}}'
      TYPE: '{{.TYPE | default "patch"}}'
    preconditions:
      - sh: '[ -n "{{.MODULE}}" ]'
        msg: "MODULE is required. Usage: task version:bump MODULE=schemas TYPE=patch"
      - sh: command -v yq >/dev/null 2>&1
        msg: "yq is required. Install: brew install yq"
    cmds:
      - |
        CURRENT=$(yq '.{{.MODULE}}.version' {{.VERSION_FILE}} | sed 's/^v//')
        
        if [ "$CURRENT" = "null" ]; then
          echo "Error: Module '{{.MODULE}}' not found in {{.VERSION_FILE}}"
          exit 1
        fi
        
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
        
        case "{{.TYPE}}" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
          *)
            echo "Invalid TYPE: {{.TYPE}}. Use patch, minor, or major."
            exit 1
            ;;
        esac
        
        NEW="v${MAJOR}.${MINOR}.${PATCH}"
        yq -i '.{{.MODULE}}.version = "'$NEW'"' {{.VERSION_FILE}}
        echo "Bumped {{.MODULE}}: v${CURRENT} -> ${NEW}"

  # ============================================================================
  # Publishing
  # ============================================================================

  publish:local:
    desc: Publish module to local registry (MODULE required)
    summary: |
      Publish a specific catalog module to the local OCI registry.

      Usage:
        task publish:local MODULE=schemas              # Use version from versions.yml
        task publish:local MODULE=schemas VERSION=v0.2.0  # Use explicit version
    vars:
      MODULE: '{{.MODULE | default ""}}'
      VERSION: '{{.VERSION | default ""}}'
    preconditions:
      - sh: '[ -n "{{.MODULE}}" ]'
        msg: "MODULE is required. Usage: task publish:local MODULE=schemas"
      - sh: command -v yq >/dev/null 2>&1
        msg: "yq is required. Install: brew install yq"
    cmds:
      - |
        if [ -z "{{.VERSION}}" ]; then
          VERSION=$(yq '.{{.MODULE}}.version' {{.VERSION_FILE}})
        else
          VERSION="{{.VERSION}}"
        fi
        
        if [ "$VERSION" = "null" ]; then
          echo "Error: Module '{{.MODULE}}' not found in {{.VERSION_FILE}}"
          exit 1
        fi
        
        echo "Publishing {{.MODULE}}@$VERSION to {{.LOCAL_REGISTRY}}..."
        cd "{{.V0_DIR}}/{{.MODULE}}" && cue mod publish "$VERSION"
        echo "Published {{.MODULE}}@$VERSION"

  publish:all:local:
    desc: Publish all modules to local registry (dependency order)
    summary: |
      Publish all catalog modules to the local OCI registry in dependency order.

      Usage:
        task publish:all:local
    preconditions:
      - sh: command -v yq >/dev/null 2>&1
        msg: "yq is required. Install: brew install yq"
    cmds:
      - |
        echo "Publishing all catalog modules to local registry..."
        echo ""
        
        {{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}
        VERSION=$(yq '.{{$mod.name}}.version' {{$.VERSION_FILE}})
        echo "Publishing {{$mod.name}}@$VERSION..."
        
        if (cd "{{$.V0_DIR}}/{{$mod.path}}" && \
            cue mod publish "$VERSION" 2>&1); then
          echo "  Published {{$mod.name}}@$VERSION"
        else
          echo "  Failed to publish {{$mod.name}}"
          exit 1
        fi
        echo ""
        {{end}}{{end}}
        
        echo "All catalog modules published to {{.LOCAL_REGISTRY}}"

  publish:smart:
    desc: Auto-detect changes, cascade bump, and publish
    deps:
      - fmt
      - vet
    summary: |
      Detect which modules have source changes (via checksum comparison),
      compute the dependency cascade, bump versions, update dependency pins,
      tidy, and publish in topological order.

      Change detection uses SHA-256 checksums of .cue files (excluding cue.mod/)
      stored in versions.yml. This works regardless of git commit state.

      Usage:
        task publish:smart                    # Detect, bump patch, publish
        task publish:smart DRY_RUN=true       # Preview without executing
        task publish:smart TYPE=minor         # Minor bump instead of patch
    vars:
      DRY_RUN: '{{.DRY_RUN | default "false"}}'
      TYPE: '{{.TYPE | default "patch"}}'
    preconditions:
      - sh: command -v yq >/dev/null 2>&1
        msg: "yq is required. Install: brew install yq"
      - sh: command -v cue >/dev/null 2>&1
        msg: "cue is required. Install: go install cuelang.org/go/cmd/cue@latest"
      - sh: command -v git >/dev/null 2>&1
        msg: "git is required"
    cmds:
      - |
        set -euo pipefail

        # ── Config (injected from Go templates) ─────────────────────
        V0_DIR="{{.V0_DIR}}"
        VERSION_FILE="{{.VERSION_FILE}}"
        DRY_RUN="{{.DRY_RUN}}"
        BUMP_TYPE="{{.TYPE}}"

        MODULES=({{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}"{{$mod.name}}" {{end}}{{end}})
        PATHS=({{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}"{{$mod.path}}" {{end}}{{end}})
        {{range $mod := .CATALOG_MODULES}}{{if $mod.enabled}}
        DEPS_{{$mod.name}}="{{$mod.deps}}"{{end}}{{end}}

        # ── Colors ────────────────────────────────────────────────────
        BOLD='\033[1m'
        DIM='\033[2m'
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[0;33m'
        CYAN='\033[0;36m'
        RESET='\033[0m'

        # ── Helper functions ─────────────────────────────────────────

        # Get current version from versions.yml
        get_version() {
          yq ".$1.version" "$VERSION_FILE"
        }

        # Get stored checksum from versions.yml
        get_stored_checksum() {
          yq ".$1.checksum // \"\"" "$VERSION_FILE"
        }

        # Compute checksum of .cue files in a module (excluding cue.mod/)
        compute_checksum() {
          local path="$1"
          find "$V0_DIR/$path" -name '*.cue' -not -path '*/cue.mod/*' | sort | xargs sha256sum | sha256sum | awk '{print $1}'
        }

        # Bump a version string: bump_version v0.1.0 patch → v0.1.1
        bump_version() {
          local ver="$1"
          local type="$2"
          local stripped="${ver#v}"
          IFS='.' read -r major minor patch <<< "$stripped"
          case "$type" in
            major) major=$((major + 1)); minor=0; patch=0 ;;
            minor) minor=$((minor + 1)); patch=0 ;;
            patch) patch=$((patch + 1)) ;;
          esac
          echo "v${major}.${minor}.${patch}"
        }

        # Affected set as space-separated string
        AFFECTED=""

        is_affected() {
          [[ " $AFFECTED " == *" $1 "* ]]
        }

        mark_affected() {
          if ! is_affected "$1"; then
            AFFECTED="$AFFECTED $1"
          fi
        }

        # ── Phase 1: Detect changes (checksum-based) ────────────────

        echo -e "${BOLD}Phase 1: Detecting changes...${RESET}"
        CHANGED=""

        # Store computed checksums for later
        declare -A CURRENT_CHECKSUMS

        for i in "${!MODULES[@]}"; do
          mod="${MODULES[$i]}"
          path="${PATHS[$i]}"
          stored=$(get_stored_checksum "$mod")
          current=$(compute_checksum "$path")
          CURRENT_CHECKSUMS[$mod]="$current"

          if [ -z "$stored" ]; then
            echo -e "  ${YELLOW}$mod${RESET}: ${YELLOW}changed${RESET} (no stored checksum)"
            CHANGED="$CHANGED $mod"
          elif [ "$stored" != "$current" ]; then
            echo -e "  ${YELLOW}$mod${RESET}: ${YELLOW}changed${RESET}"
            CHANGED="$CHANGED $mod"
          else
            echo -e "  ${DIM}$mod: unchanged${RESET}"
          fi
        done

        if [ -z "$CHANGED" ]; then
          echo ""
          echo -e "${GREEN}No changes detected. Nothing to publish.${RESET}"
          exit 0
        fi

        # ── Phase 2: Compute cascade ────────────────────────────────

        echo ""
        echo -e "${BOLD}Phase 2: Computing cascade...${RESET}"

        # Seed AFFECTED with directly changed modules
        for mod in $CHANGED; do
          mark_affected "$mod"
        done

        # Walk topo order, add dependents
        for mod in "${MODULES[@]}"; do
          if is_affected "$mod"; then
            continue
          fi
          dep_var="DEPS_${mod}"
          for dep in ${!dep_var}; do
            if is_affected "$dep"; then
              mark_affected "$mod"
              echo -e "  ${CYAN}$mod${RESET}: added (depends on ${YELLOW}$dep${RESET})"
              break
            fi
          done
        done

        echo ""
        echo -e "Affected modules:${YELLOW}$AFFECTED${RESET}"

        # ── Dry run exit ─────────────────────────────────────────────

        if [ "$DRY_RUN" = "true" ]; then
          echo ""
          echo -e "${BOLD}Dry run — planned actions:${RESET}"
          for mod in "${MODULES[@]}"; do
            if is_affected "$mod"; then
              version=$(get_version "$mod")
              new_version=$(bump_version "$version" "$BUMP_TYPE")
              echo -e "  ${YELLOW}$mod${RESET}: $version -> ${GREEN}$new_version${RESET} (bump + publish)"
            fi
          done
          echo ""
          echo -e "${DIM}No changes made (dry run).${RESET}"
          exit 0
        fi

        # ── Phase 3: Bump, update pins, tidy, publish, tag ──────────

        echo ""
        echo -e "${BOLD}Phase 3: Publishing...${RESET}"

        for i in "${!MODULES[@]}"; do
          mod="${MODULES[$i]}"
          path="${PATHS[$i]}"

          if ! is_affected "$mod"; then
            continue
          fi

          # 1. Bump version
          old_version=$(get_version "$mod")
          new_version=$(bump_version "$old_version" "$BUMP_TYPE")
          yq -i ".${mod}.version = \"${new_version}\"" "$VERSION_FILE"
          echo ""
          echo -e "${BOLD}${GREEN}[$mod]${RESET} $old_version -> ${GREEN}$new_version${RESET}"

          # 2. Update dependency pins (deps already bumped in versions.yml due to topo order)
          dep_var="DEPS_${mod}"
          for dep in ${!dep_var}; do
            if is_affected "$dep"; then
              dep_new_ver=$(get_version "$dep")
              sed -i '/"opmodel.dev\/'"$dep"'@v0":/,/}/ s/v: ".*"/v: "'"$dep_new_ver"'"/' \
                "$V0_DIR/$path/cue.mod/module.cue"
              echo -e "  Updated pin: $dep -> ${CYAN}$dep_new_ver${RESET}"
            fi
          done

          # 3. Tidy
          echo "  Tidying..."
          (cd "$V0_DIR/$path" && cue mod tidy)

          # 4. Publish
          echo "  Publishing ${mod}@${new_version}..."
          if ! (cd "$V0_DIR/$path" && cue mod publish "$new_version"); then
            echo -e "  ${RED}Failed to publish $mod${RESET}"
            exit 1
          fi

          # 5. Tag
          git tag "catalog/${mod}/${new_version}"
          echo "  Tagged catalog/${mod}/${new_version}"

          # 6. Store checksum (recompute after tidy may have changed cue.mod/)
          new_checksum=$(compute_checksum "$path")
          yq -i ".${mod}.checksum = \"${new_checksum}\"" "$VERSION_FILE"
          echo -e "  Checksum: ${DIM}${new_checksum:0:12}...${RESET}"
        done

        echo ""
        echo -e "${BOLD}${GREEN}Done.${RESET} Published:${YELLOW}$AFFECTED${RESET}"
