version: '3'

# Catalog CUE Module Taskfile
# Tasks for the v1alpha1/ module (opmodel.dev@v1).
#
# Usage:
#   task fmt
#   task vet
#   task publish:local
#   task publish:smart

# Silent by default - set TASK_VERBOSE=1 or use --verbose to show commands
silent: true

includes:
  # Core configuration (provides shared variables)
  config:
    taskfile: .tasks/config.yml
    internal: true

  # Docker OCI registry management
  registry:
    taskfile: .tasks/registry/docker.yml
    dir: .

  # Dependency management
  deps:
    taskfile: .tasks/deps.yml
    dir: .

env:
  CUE_REGISTRY: '{{.LOCAL_REGISTRY}}'
  CUE_CACHE_DIR: '{{.TASKFILE_DIR}}/../.cue-cache'

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  # ============================================================================
  # Formatting
  # ============================================================================

  fmt:
    desc: Format CUE files
    cmds:
      - |
        echo "Formatting {{.V1ALPHA1_DIR}}..."
        cd "{{.V1ALPHA1_DIR}}" && cue fmt ./...
        echo "Done"

  # ============================================================================
  # Validation
  # ============================================================================

  vet:
    desc: Validate CUE files
    summary: |
      Validate CUE files in the v1alpha1 module.

      Usage:
        task vet
        task vet CONCRETE=true    # Validate with concreteness checks
    vars:
      CONCRETE: '{{.CONCRETE | default "false"}}'
      VET_FLAGS: '{{if eq .CONCRETE "true"}}-c{{end}}'
    cmds:
      - |
        echo "Validating {{.V1ALPHA1_DIR}}{{if eq .CONCRETE "true"}} (concrete){{end}}..."
        cd "{{.V1ALPHA1_DIR}}" && cue vet {{.VET_FLAGS}} ./...
        echo "Done"

  eval:
    desc: Evaluate CUE files
    summary: |
      Evaluate CUE files in the v1alpha1 module.

      Usage:
        task eval
        task eval OUTPUT=out.cue    # Write output to file
    vars:
      OUTPUT: '{{.OUTPUT | default ""}}'
      EVAL_REDIRECT: '{{if .OUTPUT}}> {{.OUTPUT}}{{end}}'
    cmds:
      - |
        echo "Evaluating {{.V1ALPHA1_DIR}}..."
        cd "{{.V1ALPHA1_DIR}}" && cue eval ./... {{.EVAL_REDIRECT}}
        echo "Done"

  # ============================================================================
  # Testing
  # ============================================================================

  test:
    desc: Run CUE definition tests
    summary: |
      Run unit tests for CUE definitions in v1alpha1.

      Tests are organized in two layers:
        1. Positive CUE tests: *_tests.cue files with @if(test) — validated via unification with concreteness check (-c).
           Value assertions (field: expr, field: "expected") verify correct values. Exported fields (no _ prefix)
           also verify that values are concrete (not just schema-level types).
        2. Data validation tests: testdata/*.yaml files — positive (valid) and negative (invalid)

      Naming conventions for testdata files:
        <definition>_valid_<description>.yaml    → must pass cue vet
        <definition>_invalid_<description>.yaml  → must fail cue vet

      Usage:
        task test
    cmds:
      - |
        set -euo pipefail

        # ── Colors ────────────────────────────────────────────────────
        BOLD='\033[1m'
        DIM='\033[2m'
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[0;33m'
        CYAN='\033[0;36m'
        RESET='\033[0m'

        PASSED=0
        FAILED=0
        SKIPPED=0
        ERRORS=""

        # Convert kebab-case to PascalCase
        kebab_to_pascal() {
          echo "$1" | sed -r 's/(^|[-])([a-z])/\U\2/g'
        }

        MOD_DIR="{{.V1ALPHA1_DIR}}"

        echo -e "${BOLD}Running CUE definition tests${RESET}"
        echo ""

        # ── Layer 1: Positive CUE tests (@if(test) files) ──────────
        test_file_count=$(find "$MOD_DIR" -name '*_tests.cue' 2>/dev/null | wc -l)

        if [ "$test_file_count" -gt 0 ]; then
          echo -e "${BOLD}[v1alpha1]${RESET} CUE unification tests"
          local output
          if output=$(cd "$MOD_DIR" && cue vet -c -t test ./... 2>&1); then
            echo -e "  ${GREEN}PASS${RESET}  cue vet -c -t test ./..."
            PASSED=$((PASSED + 1))
          else
            echo -e "  ${RED}FAIL${RESET}  cue vet -c -t test ./..."
            echo "$output" | sed 's/^/         /'
            FAILED=$((FAILED + 1))
            ERRORS="${ERRORS}\n  v1alpha1: CUE unification tests failed"
          fi
        fi

        # ── Layer 2: Data file tests (testdata/) ─────────────────
        for testdata_dir in $(find "$MOD_DIR" -type d -name 'testdata' 2>/dev/null); do
          for datafile in "$testdata_dir"/*.yaml "$testdata_dir"/*.json; do
            [ -f "$datafile" ] || continue

            basename=$(basename "$datafile")
            noext="${basename%.*}"

            def_kebab=$(echo "$noext" | sed 's/_\(valid\|invalid\)_.*//')
            def_pascal=$(kebab_to_pascal "$def_kebab")
            def="#${def_pascal}"

            rel_datafile="${datafile#$MOD_DIR/}"

            if echo "$noext" | grep -q '_valid_'; then
              if output=$(cd "$MOD_DIR" && cue vet -d "$def" ./... "$rel_datafile" 2>&1); then
                echo -e "  ${GREEN}PASS${RESET}  ${DIM}${basename}${RESET} → ${CYAN}${def}${RESET} (expect: valid)"
                PASSED=$((PASSED + 1))
              else
                echo -e "  ${RED}FAIL${RESET}  ${basename} → ${def} (expected valid, got error)"
                echo "$output" | sed 's/^/         /'
                FAILED=$((FAILED + 1))
                ERRORS="${ERRORS}\n  v1alpha1: ${basename} expected valid but got error"
              fi
            elif echo "$noext" | grep -q '_invalid_'; then
              if (cd "$MOD_DIR" && cue vet -d "$def" ./... "$rel_datafile" >/dev/null 2>&1); then
                echo -e "  ${RED}FAIL${RESET}  ${basename} → ${def} (expected invalid, but passed)"
                FAILED=$((FAILED + 1))
                ERRORS="${ERRORS}\n  v1alpha1: ${basename} expected invalid but passed"
              else
                echo -e "  ${GREEN}PASS${RESET}  ${DIM}${basename}${RESET} → ${CYAN}${def}${RESET} (expect: invalid)"
                PASSED=$((PASSED + 1))
              fi
            else
              echo -e "  ${YELLOW}SKIP${RESET}  ${basename} (filename must contain _valid_ or _invalid_)"
              SKIPPED=$((SKIPPED + 1))
            fi
          done
        done

        if [ $((PASSED + FAILED + SKIPPED)) -eq 0 ]; then
          echo -e "${DIM}[v1alpha1] no tests found${RESET}"
        fi

        # ── Summary ─────────────────────────────────────────────────
        echo ""
        TOTAL=$((PASSED + FAILED + SKIPPED))
        echo -e "${BOLD}Results: ${GREEN}${PASSED} passed${RESET}, ${RED}${FAILED} failed${RESET}, ${YELLOW}${SKIPPED} skipped${RESET} (${TOTAL} total)"

        if [ $FAILED -gt 0 ]; then
          echo -e "\n${RED}Failures:${ERRORS}${RESET}"
          exit 1
        fi

  # ============================================================================
  # Module Management
  # ============================================================================

  tidy:
    desc: Tidy module dependencies
    cmds:
      - |
        echo "Tidying {{.V1ALPHA1_DIR}} dependencies..."
        cd "{{.V1ALPHA1_DIR}}" && cue mod tidy
        echo "Done"

  # ============================================================================
  # Watch Mode
  # ============================================================================

  watch:fmt:
    desc: Watch and auto-format on changes
    preconditions:
      - sh: command -v watchexec
        msg: "watchexec is required. Install: brew install watchexec"
    cmds:
      - |
        echo "Watching {{.V1ALPHA1_DIR}} for changes..."
        echo "Press Ctrl+C to stop"
        watchexec -w "{{.V1ALPHA1_DIR}}" -e cue -- bash -c '
          cd "{{.V1ALPHA1_DIR}}" && cue fmt ./...
          echo "Formatted"
        '

  watch:vet:
    desc: Watch and auto-validate on changes
    preconditions:
      - sh: command -v watchexec
        msg: "watchexec is required. Install: brew install watchexec"
    cmds:
      - |
        echo "Watching {{.V1ALPHA1_DIR}} for changes..."
        echo "Press Ctrl+C to stop"
        watchexec -w "{{.V1ALPHA1_DIR}}" -e cue -- bash -c '
          if cd "{{.V1ALPHA1_DIR}}" && cue vet ./... 2>&1; then
            echo "Valid"
          else
            echo "Validation failed"
          fi
        '

  # ============================================================================
  # Combined Operations
  # ============================================================================

  check:
    desc: Run fmt and vet
    cmds:
      - task fmt
      - task vet

  # ============================================================================
  # Version Management
  # ============================================================================

  version:
    desc: Show current module version
    preconditions:
      - sh: command -v yq >/dev/null 2>&1
        msg: "yq is required. Install: brew install yq"
    cmds:
      - |
        VERSION=$(yq '.v1alpha1.version' {{.VERSION_FILE}})
        echo "v1alpha1: $VERSION"

  version:bump:
    desc: Bump module version (TYPE=patch/minor/major)
    summary: |
      Bump the version for the v1alpha1 module following SemVer.

      Usage:
        task version:bump              # Bump patch (default)
        task version:bump TYPE=patch   # v1.0.0 -> v1.0.1
        task version:bump TYPE=minor   # v1.0.0 -> v1.1.0
        task version:bump TYPE=major   # v1.0.0 -> v2.0.0
    vars:
      TYPE: '{{.TYPE | default "patch"}}'
    preconditions:
      - sh: command -v yq >/dev/null 2>&1
        msg: "yq is required. Install: brew install yq"
    cmds:
      - |
        CURRENT=$(yq '.v1alpha1.version' {{.VERSION_FILE}} | sed 's/^v//')

        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

        case "{{.TYPE}}" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
          *)
            echo "Invalid TYPE: {{.TYPE}}. Use patch, minor, or major."
            exit 1
            ;;
        esac

        NEW="v${MAJOR}.${MINOR}.${PATCH}"
        yq -i '.v1alpha1.version = "'$NEW'"' {{.VERSION_FILE}}
        echo "Bumped v1alpha1: v${CURRENT} -> ${NEW}"

  # ============================================================================
  # Publishing
  # ============================================================================

  publish:local:
    desc: Publish v1alpha1 to local registry
    summary: |
      Publish the v1alpha1 module to the local OCI registry.

      Usage:
        task publish:local              # Use version from versions.yml
        task publish:local VERSION=v1.0.1  # Use explicit version
    vars:
      VERSION: '{{.VERSION | default ""}}'
    preconditions:
      - sh: command -v yq >/dev/null 2>&1
        msg: "yq is required. Install: brew install yq"
    cmds:
      - |
        if [ -z "{{.VERSION}}" ]; then
          VERSION=$(yq '.v1alpha1.version' {{.VERSION_FILE}})
        else
          VERSION="{{.VERSION}}"
        fi

        echo "Publishing v1alpha1@$VERSION to {{.LOCAL_REGISTRY}}..."
        cd "{{.V1ALPHA1_DIR}}" && cue mod publish "$VERSION"
        echo "Published v1alpha1@$VERSION"

  publish:smart:
    desc: Auto-detect changes, bump version, and publish
    deps:
      - fmt
      - vet
    summary: |
      Detect whether the v1alpha1 module has source changes (via checksum comparison),
      bump the version, tidy, and publish.

      Change detection uses SHA-256 checksums of .cue files (excluding cue.mod/)
      stored in versions.yml.

      Usage:
        task publish:smart                    # Detect, bump patch, publish
        task publish:smart DRY_RUN=true       # Preview without executing
        task publish:smart TYPE=minor         # Minor bump instead of patch
    vars:
      DRY_RUN: '{{.DRY_RUN | default "false"}}'
      TYPE: '{{.TYPE | default "patch"}}'
    preconditions:
      - sh: command -v yq >/dev/null 2>&1
        msg: "yq is required. Install: brew install yq"
      - sh: command -v cue >/dev/null 2>&1
        msg: "cue is required. Install: go install cuelang.org/go/cmd/cue@latest"
      - sh: command -v git >/dev/null 2>&1
        msg: "git is required"
    cmds:
      - |
        set -euo pipefail

        MODULE_DIR="{{.V1ALPHA1_DIR}}"
        VERSION_FILE="{{.VERSION_FILE}}"
        DRY_RUN="{{.DRY_RUN}}"
        BUMP_TYPE="{{.TYPE}}"

        # ── Colors ────────────────────────────────────────────────────
        BOLD='\033[1m'
        DIM='\033[2m'
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[0;33m'
        RESET='\033[0m'

        # ── Helper functions ─────────────────────────────────────────

        get_version() {
          yq '.v1alpha1.version' "$VERSION_FILE"
        }

        get_stored_checksum() {
          yq '.v1alpha1.checksum // ""' "$VERSION_FILE"
        }

        compute_checksum() {
          find "$MODULE_DIR" -name '*.cue' -not -path '*/cue.mod/*' | sort | xargs sha256sum | sha256sum | awk '{print $1}'
        }

        bump_version() {
          local ver="$1"
          local type="$2"
          local stripped="${ver#v}"
          IFS='.' read -r major minor patch <<< "$stripped"
          case "$type" in
            major) major=$((major + 1)); minor=0; patch=0 ;;
            minor) minor=$((minor + 1)); patch=0 ;;
            patch) patch=$((patch + 1)) ;;
          esac
          echo "v${major}.${minor}.${patch}"
        }

        # ── Phase 1: Detect changes ──────────────────────────────────

        echo -e "${BOLD}Phase 1: Detecting changes...${RESET}"

        stored=$(get_stored_checksum)
        current=$(compute_checksum)

        if [ -z "$stored" ]; then
          echo -e "  ${YELLOW}v1alpha1${RESET}: changed (no stored checksum)"
        elif [ "$stored" != "$current" ]; then
          echo -e "  ${YELLOW}v1alpha1${RESET}: changed"
        else
          echo -e "  v1alpha1: unchanged"
          echo ""
          echo -e "${GREEN}No changes detected. Nothing to publish.${RESET}"
          exit 0
        fi

        version=$(get_version)
        new_version=$(bump_version "$version" "$BUMP_TYPE")

        # ── Dry run exit ─────────────────────────────────────────────

        if [ "$DRY_RUN" = "true" ]; then
          echo ""
          echo -e "${BOLD}Dry run — planned actions:${RESET}"
          echo -e "  ${YELLOW}v1alpha1${RESET}: $version -> ${GREEN}$new_version${RESET} (bump + publish)"
          echo ""
          echo -e "${DIM}No changes made (dry run).${RESET}"
          exit 0
        fi

        # ── Phase 2: Bump, tidy, publish, tag ───────────────────────

        echo ""
        echo -e "${BOLD}Phase 2: Publishing...${RESET}"
        echo ""
        echo -e "${BOLD}${GREEN}[v1alpha1]${RESET} $version -> ${GREEN}$new_version${RESET}"

        # 1. Bump version
        yq -i ".v1alpha1.version = \"${new_version}\"" "$VERSION_FILE"

        # 2. Tidy
        echo "  Tidying..."
        (cd "$MODULE_DIR" && cue mod tidy)

        # 3. Publish
        echo "  Publishing v1alpha1@${new_version}..."
        if ! (cd "$MODULE_DIR" && cue mod publish "$new_version"); then
          echo -e "  ${RED}Failed to publish v1alpha1${RESET}"
          exit 1
        fi

        # 4. Tag
        git tag "catalog/v1alpha1/${new_version}"
        echo "  Tagged catalog/v1alpha1/${new_version}"

        # 5. Store checksum
        new_checksum=$(compute_checksum)
        yq -i ".v1alpha1.checksum = \"${new_checksum}\"" "$VERSION_FILE"
        echo -e "  Checksum: ${DIM}${new_checksum:0:12}...${RESET}"

        echo ""
        echo -e "${BOLD}${GREEN}Done.${RESET} Published v1alpha1@${new_version}"
