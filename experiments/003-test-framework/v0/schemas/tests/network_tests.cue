@if(test)

package schemas

import (
	tst "experiments.dev/test-framework/testkit"
)

// ── Port boundary data ──
_portValid:   [1, 2, 80, 443, 8080, 65535]
_portInvalid: [0, -1, 65536, 70000]

// Protocol validity map: true = valid, false = invalid
_protocols: {
	TCP:  true
	UDP:  true
	SCTP: true
	HTTP: false
	WSS:  false
}

// HTTP method validity
_httpMethodsValid:   ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]
_httpMethodsInvalid: ["CONNECT", "TRACE", "BANANA"]

// IANA service name validity
_ianaValid:   ["http", "my-svc", "a", "abcdefghijklmno", "a1", "a-1"]
_ianaInvalid: ["-http", "http-", "MY-SVC", "abcdefghijklmnop"]

#tests: tst.#Tests & {

	// =========================================================================
	// #PortSchema
	// =========================================================================

	"#PortSchema": [

		// Valid ports generated from boundary table
		for p in _portValid {
			name:       "port \(p) valid"
			definition: #PortSchema
			input: {name: "svc", targetPort: p}
			assert: valid: true
		},

		// Invalid ports generated from boundary table
		for p in _portInvalid {
			name:       "port \(p) invalid"
			definition: #PortSchema
			input: {name: "http", targetPort: p}
			assert: valid: false
		},

		// Protocol matrix: valid/invalid driven by _protocols map value
		for proto, ok in _protocols {
			name:       "protocol \(proto)"
			definition: #PortSchema
			input: {name: "svc", targetPort: 8080, protocol: proto}
			assert: valid: ok
		},
	]

	// =========================================================================
	// #ExposeSchema
	// =========================================================================

	"#ExposeSchema": [

		// ── Positive ──
		{
			name:       "ClusterIP"
			definition: #ExposeSchema
			input: {
				ports: http: {
					name:       "http"
					targetPort: 80
				}
				type: "ClusterIP"
			}
			assert: valid: true
		},
		{
			name:       "LoadBalancer"
			definition: #ExposeSchema
			input: {
				ports: {
					http: {
						name:       "http"
						targetPort: 80
					}
					https: {
						name:       "https"
						targetPort: 443
					}
				}
				type: "LoadBalancer"
			}
			assert: valid: true
		},
		{
			name:       "NodePort"
			definition: #ExposeSchema
			input: {
				ports: http: {
					name:       "http"
					targetPort: 8080
				}
				type: "NodePort"
			}
			assert: valid: true
		},

		// ── Negative ──
		{
			name:       "bad type"
			definition: #ExposeSchema
			input: {
				ports: http: {
					name:       "http"
					targetPort: 80
				}
				type: "ExternalName"
			}
			assert: valid: false
		},
	]

	// =========================================================================
	// #HttpRouteSchema
	// =========================================================================

	"#HttpRouteSchema": [

		// ── Positive ──
		{
			name:       "basic"
			definition: #HttpRouteSchema
			input: {
				hostnames: ["example.com"]
				rules: [{
					backendPort: 8080
					matches: [{
						path: {
							type:  "Prefix"
							value: "/"
						}
					}]
				}]
			}
			assert: valid: true
		},
		{
			name:       "full with TLS and gateway"
			definition: #HttpRouteSchema
			input: {
				hostnames: ["api.example.com"]
				gatewayRef: {
					name:      "main-gateway"
					namespace: "gateway-system"
				}
				tls: {
					mode: "Terminate"
					certificateRef: {
						name:      "api-cert"
						namespace: "cert-manager"
					}
				}
				rules: [
					{
						backendPort: 8080
						matches: [{
							path: {
								type:  "Prefix"
								value: "/api/v1"
							}
							method: "GET"
							headers: [{
								name:  "X-API-Version"
								value: "v1"
							}]
						}]
					},
					{
						backendPort: 8081
						matches: [{
							path: {
								type:  "Exact"
								value: "/health"
							}
						}]
					},
				]
			}
			assert: valid: true
		},

		// Valid HTTP methods: one test case per method, generated by for loop
		for m in _httpMethodsValid {
			name:       "method \(m)"
			definition: #HttpRouteSchema
			input: {
				hostnames: ["api.example.com"]
				rules: [{
					backendPort: 8080
					matches: [{
						path: {type: "Prefix", value: "/"}
						method: m
					}]
				}]
			}
			assert: valid: true
		},

		// Invalid HTTP methods generated by for loop
		for m in _httpMethodsInvalid {
			name:       "bad method \(m)"
			definition: #HttpRouteSchema
			input: {
				hostnames: ["api.example.com"]
				rules: [{
					backendPort: 8080
					matches: [{
						path: {type: "Prefix", value: "/"}
						method: m
					}]
				}]
			}
			assert: valid: false
		},

		// ── Negative ──
		{
			name:       "empty rules"
			definition: #HttpRouteSchema
			input: {
				hostnames: ["example.com"]
				rules: []
			}
			assert: valid: false
		},
	]

	// =========================================================================
	// #GrpcRouteSchema
	// =========================================================================

	"#GrpcRouteSchema": [
		{
			name:       "basic"
			definition: #GrpcRouteSchema
			input: {
				hostnames: ["grpc.example.com"]
				rules: [{
					backendPort: 9090
					matches: [{
						service: "my.package.Service"
						method:  "GetItem"
					}]
				}]
			}
			assert: valid: true
		},
	]

	// =========================================================================
	// #TcpRouteSchema
	// =========================================================================

	"#TcpRouteSchema": [
		{
			name:       "basic"
			definition: #TcpRouteSchema
			input: rules: [{backendPort: 5432}]
			assert: valid: true
		},
	]

	// =========================================================================
	// #IANA_SVC_NAME
	// =========================================================================

	"#IANA_SVC_NAME": [
		// Valid names from data table
		for s in _ianaValid {
			name:       "\(s) valid"
			definition: #IANA_SVC_NAME
			input:      s
			assert: valid: true
		},
		// Invalid names from data table
		for s in _ianaInvalid {
			name:       "\(s) invalid"
			definition: #IANA_SVC_NAME
			input:      s
			assert: valid: false
		},
	]

	// =========================================================================
	// #RouteAttachmentSchema
	// =========================================================================

	"#RouteAttachmentSchema": [
		{
			name:       "terminate"
			definition: #RouteAttachmentSchema
			input: {
				gatewayRef: {
					name:      "gateway"
					namespace: "default"
				}
				tls: {
					mode: "Terminate"
					certificateRef: name: "cert"
				}
			}
			assert: valid: true
		},
		{
			name:       "passthrough"
			definition: #RouteAttachmentSchema
			input: {
				gatewayRef: name: "gateway"
				tls: mode:        "Passthrough"
			}
			assert: valid: true
		},
	]
}
